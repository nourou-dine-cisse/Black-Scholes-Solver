#ifndef SDL_HPP
#define SDL_HPP

#include <SDL2/SDL.h>
#include <vector>
#include <string>

class Sdl
{
private:
	SDL_Window *window;
	SDL_Renderer *renderer;
	int _width;
	int _height;
	bool _isOpen;

public:
	Sdl(std::string title, int width, int height);
	~Sdl();

	void drawCurve(const std::vector<double> &x_data, const std::vector<double> &y_data, SDL_Color color);

	void present();
	void clear();
	bool isOpen();
};

#endif

#include "sdl.hpp"

Sdl::Sdl(std::string title, int width, int height) : _width(width), _height(height), _isOpen(true)
{
	if (SDL_Init(SDL_INIT_VIDEO) < 0)
	{
		// Gestion d'erreur basique
		_isOpen = false;
		return;
	}
	window = SDL_CreateWindow(title.c_str(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_SHOWN);
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
}

Sdl::~Sdl()
{
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	SDL_Quit();
}

bool Sdl::isOpen()
{
	return _isOpen;
}

void Sdl::clear()
{
	SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // Fond blanc
	SDL_RenderClear(renderer);
}

void Sdl::present()
{
	SDL_RenderPresent(renderer);
}

void Sdl::drawCurve(const std::vector<double> &x_data, const std::vector<double> &y_data, SDL_Color color)
{
	if (x_data.empty() || y_data.empty())
		return;

	SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);

	int margin = 50;			  // La même marge que pour les axes
	double x_max = x_data.back(); // ex: 300
	double y_max = 250.0;		  // ex: 250 (Fixe une valeur max pour l'échelle Y)

	// Zone de dessin utile (largeur et hauteur intérieures)
	double draw_width = _width - 2 * margin;
	double draw_height = _height - 2 * margin;

	for (size_t i = 0; i < x_data.size() - 1; ++i)
	{
		// --- CALCUL DU POINT 1 ---
		// 1. Ratio : à quel pourcentage de la courbe sommes-nous ? (ex: 0.5 pour la moitié)
		double ratio_x1 = x_data[i] / x_max;
		double ratio_y1 = y_data[i] / y_max;

		// 2. Projection : Marge + (Ratio * TailleUtile)
		int pixel_x1 = margin + (int)(ratio_x1 * draw_width);

		// 3. Inversion Y : (HauteurTotale - Marge) - (Ratio * TailleUtile)
		// On part du bas (height - margin) et on remonte.
		int pixel_y1 = (_height - margin) - (int)(ratio_y1 * draw_height);

		// --- CALCUL DU POINT 2 (Le suivant) ---
		double ratio_x2 = x_data[i + 1] / x_max;
		double ratio_y2 = y_data[i + 1] / y_max;

		int pixel_x2 = margin + (int)(ratio_x2 * draw_width);
		int pixel_y2 = (_height - margin) - (int)(ratio_y2 * draw_height);

		// Tracé du segment
		SDL_RenderDrawLine(renderer, pixel_x1, pixel_y1, pixel_x2, pixel_y2);
	}
}
// Initialisation fenêtre
Sdl winPrice("Comparaison des Prix", 800, 600);

SDL_Color red = {255, 0, 0, 255};
// SDL_Color blue = {0, 0, 255, 255}; // Pour plus tard

// Boucle d'affichage
while (winPrice.isOpen())
{
	SDL_Event e;
	// On vide la file d'attente des événements
	while (SDL_PollEvent(&e))
	{
		if (e.type == SDL_QUIT)
		{
			return 0; // On quitte le programme proprement
		}
	}

	winPrice.clear();
	winPrice.drawCurve(S, V_call[0], red);
	winPrice.present();
}
